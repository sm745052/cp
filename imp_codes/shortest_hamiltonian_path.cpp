#include<bits/stdc++.h>
using namespace std;

// dp state -> dp[mask][i] be the length of the shortest Hamiltonian walk in the subgraph generated by vertices in mask, that ends in the vertex i.
// g_ is inverse of graph containing the vertices from which edges are coming to a node [not useful here but will be needed in directed graphs.]
// count function is interesting. TC = O(length(mask)) = O(n). builtin_popcount may also be used.
// below implementation is for undirected graph, unweighted and 0 indexed. it can be made directed, weighted and 1 indexed if necessary.
// reference: https://codeforces.com/blog/entry/337
// memorizarion to be done






vector<vector<int>> g, g_;


int count(int n){
    int cnt = 0;
    while(n){
        n = n & (n - 1);
        cnt++;
    }
    return cnt;
}



int f(int mask, int id){
    if(count(mask)==1 && (mask & (1<<id))){
        return 0;
    }
    if(count(mask)>1 && (mask & (1<<id))){
        int ans = 1e9;
        for(auto i:g_[id])
            ans = min(ans, f(mask ^ (1<<id), i) + 1);
        return ans;
    }
    return 1e9;
}






int main(){
    int n, m;
    cin>>n>>m;
    g.assign(n, vector<int>());
    g_.assign(n, vector<int>());
    for(int i=0;i<m;i++){
        int a, b;
        cin>>a>>b;
        g[a].push_back(b);
        g_[b].push_back(a);
        g[b].push_back(a);
        g_[a].push_back(b);
    }
    int ans = 1e9;
    for(int i=0;i<n;i++){
        cout<<f((1<<n)-1, i)<<" ----- \n";
        ans = min(ans, f((1<<n)-1, i));
    }
    cout<<ans<<"\n";
    return 0;
}
